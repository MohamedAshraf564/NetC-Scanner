Token Analysis for: test-parse.netc

Line	Col	Type			Lexeme
----	---	----			------
3	1	LINK				link
3	6	STRING_LITERAL			"mathlib.ai"
3	18	SEMICOLON			;
5	1	NETWORK				network
5	9	IDENTIFIER			calculateSum
5	21	LPAREN				(
5	22	DNUM				dnum
5	27	IDENTIFIER			a
5	28	COMMA				,
5	30	DNUM				dnum
5	35	IDENTIFIER			b
5	36	RPAREN				)
6	1	LBRACE				{
7	5	DNUM				dnum
7	10	IDENTIFIER			result
7	17	ASSIGN				=
7	19	IDENTIFIER			a
7	21	PLUS				+
7	23	IDENTIFIER			b
7	24	SEMICOLON			;
8	5	YIELD				yield
8	11	IDENTIFIER			result
8	17	SEMICOLON			;
9	1	RBRACE				}
11	1	NETWORK				network
11	9	IDENTIFIER			multiply
11	17	LPAREN				(
11	18	DNUM				dnum
11	23	IDENTIFIER			x
11	24	COMMA				,
11	26	CNUM				cnum
11	31	IDENTIFIER			y
11	32	RPAREN				)
12	1	LBRACE				{
13	5	YIELD				yield
13	11	IDENTIFIER			x
13	13	MULTIPLY			*
13	15	IDENTIFIER			y
13	16	SEMICOLON			;
14	1	RBRACE				}
16	1	INIT				init
16	5	LPAREN				(
16	6	RPAREN				)
17	1	LBRACE				{
19	5	DNUM				dnum
19	10	IDENTIFIER			counter
19	18	ASSIGN				=
19	20	INTEGER_LITERAL			0
19	21	SEMICOLON			;
20	5	DNUM				dnum
20	10	IDENTIFIER			limit
20	16	ASSIGN				=
20	18	INTEGER_LITERAL			10
20	20	SEMICOLON			;
21	5	CNUM				cnum
21	10	IDENTIFIER			rate
21	15	ASSIGN				=
21	17	FLOAT_LITERAL			0.5
21	20	SEMICOLON			;
22	5	TEXT				text
22	10	IDENTIFIER			message
22	18	ASSIGN				=
22	20	STRING_LITERAL			"Hello NetC"
22	32	SEMICOLON			;
23	5	FLAG				flag
23	10	IDENTIFIER			isActive
23	19	ASSIGN				=
23	21	BOOLEAN_LITERAL			true
23	25	SEMICOLON			;
26	5	IDENTIFIER			counter
26	13	ASSIGN				=
26	15	INTEGER_LITERAL			5
29	5	IF				if
29	8	LPAREN				(
29	9	IDENTIFIER			counter
29	17	LT				<
29	19	IDENTIFIER			limit
29	24	RPAREN				)
30	5	LBRACE				{
31	9	FORWARD				forward
31	16	LPAREN				(
31	17	IDENTIFIER			counter
31	24	RPAREN				)
31	25	SEMICOLON			;
32	5	RBRACE				}
35	5	IF				if
35	8	LPAREN				(
35	9	IDENTIFIER			isActive
35	18	EQ				==
35	21	BOOLEAN_LITERAL			true
35	25	RPAREN				)
36	5	LBRACE				{
37	9	FORWARD				forward
37	16	LPAREN				(
37	17	IDENTIFIER			message
37	24	RPAREN				)
37	25	SEMICOLON			;
38	5	RBRACE				}
39	5	ELSE				else
40	5	LBRACE				{
41	9	IDENTIFIER			counter
41	17	ASSIGN				=
41	19	INTEGER_LITERAL			0
41	20	SEMICOLON			;
42	5	RBRACE				}
45	5	UNTIL				until
45	11	LPAREN				(
45	12	IDENTIFIER			counter
45	20	GTE				>=
45	23	IDENTIFIER			limit
45	28	RPAREN				)
46	5	LBRACE				{
47	9	IDENTIFIER			counter
47	17	ASSIGN				=
47	19	IDENTIFIER			counter
47	27	PLUS				+
47	29	INTEGER_LITERAL			1
47	30	SEMICOLON			;
48	9	FORWARD				forward
48	16	LPAREN				(
48	17	IDENTIFIER			counter
48	24	RPAREN				)
48	25	SEMICOLON			;
49	5	RBRACE				}
52	5	ITERATE				iterate
52	13	LPAREN				(
52	14	DNUM				dnum
52	19	IDENTIFIER			i
52	21	ASSIGN				=
52	23	INTEGER_LITERAL			0
52	24	SEMICOLON			;
52	26	IDENTIFIER			i
52	28	LT				<
52	30	INTEGER_LITERAL			5
52	31	SEMICOLON			;
52	33	IDENTIFIER			i
52	35	ASSIGN				=
52	37	IDENTIFIER			i
52	39	PLUS				+
52	41	INTEGER_LITERAL			1
52	42	RPAREN				)
53	5	LBRACE				{
54	9	FORWARD				forward
54	16	LPAREN				(
54	17	IDENTIFIER			i
54	18	RPAREN				)
54	19	SEMICOLON			;
55	5	RBRACE				}
58	5	DNUM				dnum
58	10	IDENTIFIER			input
58	15	SEMICOLON			;
59	5	FEED				feed
59	10	IDENTIFIER			input
59	15	SEMICOLON			;
62	5	DNUM				dnum
62	10	IDENTIFIER			sum
62	14	ASSIGN				=
62	16	IDENTIFIER			calculateSum
62	28	LPAREN				(
62	29	IDENTIFIER			counter
62	36	COMMA				,
62	38	IDENTIFIER			limit
62	43	RPAREN				)
62	44	SEMICOLON			;
63	5	FORWARD				forward
63	12	LPAREN				(
63	13	IDENTIFIER			sum
63	16	RPAREN				)
63	17	SEMICOLON			;
66	5	DNUM				dnum
66	10	IDENTIFIER			complex
66	18	ASSIGN				=
66	20	LPAREN				(
66	21	IDENTIFIER			counter
66	29	PLUS				+
66	31	IDENTIFIER			limit
66	36	RPAREN				)
66	38	MULTIPLY			*
66	40	INTEGER_LITERAL			2
66	42	MINUS				-
66	44	INTEGER_LITERAL			5
66	46	DIVIDE				/
66	48	INTEGER_LITERAL			2
66	49	SEMICOLON			;
69	5	YIELD				yield
69	11	INTEGER_LITERAL			0
69	12	SEMICOLON			;
70	1	RBRACE				}
71	1	END_OF_FILE			
